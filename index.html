<!-- Syne 3.1 – v74 Fixed vibrato detection for glow trail -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VocalTuner – Syne 3.1</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html,body,#root{height:100%;overflow:hidden}
      body{background:#0b0f14;color:#e6edf3;margin:0;padding:0;overscroll-behavior:none}
      input[type="range"]{accent-color:#9ca3af}
      canvas{display:block}
      /* Prevent iOS bounce but allow interaction */
      *{-webkit-tap-highlight-color:transparent}
      .no-select{-webkit-user-select:none;user-select:none}
      /* custom track for Noise Gate slider using CSS var */
      input.ngate::-webkit-slider-runnable-track{background:var(--ngate-bg,#3f3f46);height:12px;border-radius:9999px;overflow:visible}
      input.ngate::-moz-range-track{background:var(--ngate-bg,#3f3f46);height:12px;border-radius:9999px;overflow:visible}
      input.ngate{appearance:none;-webkit-appearance:none;background:transparent;border:0;outline:none;border-radius:9999px;box-shadow:none}
      input.ngate::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;height:12px;width:12px;border:0;border-radius:9999px;background:#cbd5e1;box-shadow:0 0 0 2px rgba(0,0,0,.25);margin-top:0}
      input.ngate::-moz-range-thumb{height:12px;width:12px;border:0;border-radius:9999px;background:#cbd5e1;box-shadow:0 0 0 2px rgba(0,0,0,.25)}
      
      /* custom track for Input Gain slider using CSS var */
      input.gain::-webkit-slider-runnable-track{background:var(--gain-bg,#3f3f46);height:12px;border-radius:9999px;overflow:visible}
      input.gain::-moz-range-track{background:var(--gain-bg,#3f3f46);height:12px;border-radius:9999px;overflow:visible}
      input.gain{appearance:none;-webkit-appearance:none;background:transparent;border:0;outline:none;border-radius:9999px;box-shadow:none}
      input.gain::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;height:12px;width:12px;border:0;border-radius:9999px;background:#cbd5e1;box-shadow:0 0 0 2px rgba(0,0,0,.25);margin-top:0}
      input.gain::-moz-range-thumb{height:12px;width:12px;border:0;border-radius:9999px;background:#cbd5e1;box-shadow:0 0 0 2px rgba(0,0,0,.25)}
      
      /* Mobile-specific slider styles - vertical pills */
      @media (max-width: 768px), (hover: none) and (pointer: coarse) {
        input.ngate::-webkit-slider-thumb,
        input.gain::-webkit-slider-thumb {
          width: 12px !important;
          height: 32px !important;
          border-radius: 6px !important;
          margin-top: -10px !important;
        }
        input.ngate::-moz-range-thumb,
        input.gain::-moz-range-thumb {
          width: 12px !important;
          height: 32px !important;
          border-radius: 6px !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
      const { useEffect, useRef, useState } = React;

      // ===== Music helpers =====
      const A4 = 440, A4_MIDI = 69;
      const clamp = (n, lo, hi) => Math.min(hi, Math.max(lo, n));
      const lerp  = (a,b,t)=>a+(b-a)*t;
      const midiToFreq = m => A4 * Math.pow(2, (m - A4_MIDI) / 12);
      const freqToMidi = f => 69 + 12 * Math.log2(f / 440);
      const centsOff = (f, ref) => 1200 * Math.log2(f / Math.max(ref||1e-9, 1e-9));
      const midiToNoteName = m => { const n=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; const r=Math.round(m); return `${n[(r%12+12)%12]}${Math.floor(r/12)-1}`; };

      function isBlack(m){ const pc = ((m%12)+12)%12; return pc===1||pc===3||pc===6||pc===8||pc===10; }

      // === YIN/CMNDF detector ===
      function detectPitch(buf, sampleRate, minFreq, maxFreq){
        const N = buf.length;
        let mean=0; for(let i=0;i<N;i++) mean += buf[i]; mean/=N;
        const x=new Float32Array(N);
        for(let n=0;n<N;n++){ const w=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); x[n]=(buf[n]-mean)*w; }
        let e0=0; for(let i=0;i<N;i++) e0 += x[i]*x[i];
        const rms=Math.sqrt(e0/N); if(rms<0.008) return {freq:-1, confidence:0, rms};
        const tauMin = Math.max(2, Math.floor(sampleRate/Math.max(1e-6, maxFreq||2000)));
        const tauMax = Math.min(N-3, Math.floor(sampleRate/Math.max(1e-6, minFreq||50)));
        const d = new Float32Array(tauMax+1);
        const cmnd = new Float32Array(tauMax+1);
        d[0]=0; cmnd[0]=1;
        for(let tau=1; tau<=tauMax; tau++){
          let s=0; for(let i=0;i<N-tau;i++){ const diff=x[i]-x[i+tau]; s += diff*diff; } d[tau]=s;
        }
        let running=0; let tau=1; let bestTau=tauMin; let bestVal=1; const thresh=0.10;
        for(tau=1; tau<=tauMax; tau++){ running+=d[tau]; cmnd[tau]= d[tau]*tau/(running||1e-12); }
        let candidate=-1; for(let t=tauMin+1;t<=tauMax-1;t++){ if(cmnd[t]<thresh && cmnd[t]<=cmnd[t-1] && cmnd[t]<=cmnd[t+1]){candidate=t;break;} }
        if(candidate<0){ for(let t=tauMin;t<=tauMax;t++) if(cmnd[t]<bestVal){bestVal=cmnd[t];bestTau=t;} if(bestVal<0.35) candidate=bestTau; else return {freq:-1,confidence:0,rms}; }
        if (candidate<=tauMin+1 || candidate>=tauMax-1) return {freq:-1,confidence:0,rms};
        let t0=candidate,t1=t0; if(t0>1 && t0<tauMax){ const a=cmnd[t0-1],b=cmnd[t0],c=cmnd[t0+1]; const den=(a-2*b+c); if(Math.abs(den)>1e-12){ t1=t0+0.5*(a-c)/den; } }
        const freq = sampleRate/Math.max(1,t1);
        if(freq<(minFreq||50)*0.98 || freq>(maxFreq||2000)*1.02) return {freq:-1,confidence:0,rms};
        const confidence = Math.max(0, 1-cmnd[candidate]);
        return {freq,confidence,rms};
      }

      function App(){
        const NOTE_COLOR = {0:'#00ff4a',1:'#00d6b8',2:'#1e6aff',3:'#6b5cff',4:'#7b23ff',5:'#ff29e1',6:'#ff4396',7:'#ff2a1f',8:'#ff7a1f',9:'#ff9c1a',10:'#ffe81f',11:'#63ff3b'};

        const MIN_MIDI=36, MAX_MIDI=93, RETAIN_SEC=1200; // 20 minutes
        const headFrac=0.75;
        const containerRef=useRef(null), railRef=useRef(null), gridRef=useRef(null), traceRef=useRef(null);
        const auditionRef = useRef(false);
        
        // Detect mobile - must be before we use isMobile in state initialization
        const [isMobile, setIsMobile] = useState(() => {
          return window.innerWidth <= 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        });
        useEffect(() => {
          const checkMobile = () => {
            setIsMobile(window.innerWidth <= 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent));
          };
          checkMobile();
          window.addEventListener('resize', checkMobile);
          return () => window.removeEventListener('resize', checkMobile);
        }, []);
        
        const [semitoneH,setSemitoneH]=useState(40); const semitoneHRef=useRef(40);
        const [widthPx, setWidthPx] = useState(100); const widthPxRef = useRef(100);
        const [centerMidi,setCenterMidi]=useState(60); const centerMidiRef=useRef(60);
        const [gainDb,setGainDb]=useState(isMobile ? 13 : 0); const gainDbRef=useRef(isMobile ? 13 : 0);
        const [gateDb,setGateDb]=useState(-45); const gateDbRef=useRef(-45); 
        const [meterDb,setMeterDb]=useState(-120); const meterSmooth=useRef(-120);
        
        // Generate gain background - neutral gray fill showing slider position
        const gainBg = (() => {
          const min = -24, max = 24;
          const val = Math.max(min, Math.min(max, gainDb));
          const pct = ((val - min) / (max - min)) * 100;
          const fillColor = '#9ca3af'; // neutral gray
          return `linear-gradient(to right, ${fillColor} 0%, ${fillColor} ${pct}%, #3f3f46 ${pct}%, #3f3f46 100%)`;
        })();
        
        // Generate noise gate background with level indicator
        const gateBg = (()=>{ 
          const min=-80, max=-5; 
          const m=Math.max(min, Math.min(max, Number.isFinite(meterDb)? meterDb : min)); 
          const pct=((m-min)/(max-min))*100; 
          // Color based on whether signal is passing through the gate
          const meterColor = (meterDb > gateDb) ? '#22c55e' : '#606069'; // green if above gate, gray if below
          return `linear-gradient(to right, ${meterColor} 0%, ${meterColor} ${pct}%, #3f3f46 ${pct}%, #3f3f46 100%)`; 
        })();
        
        const [playing,setPlaying]=useState(false); const playingRef=useRef(false);
        const scrollOffsetX=useRef(0); const drawNowRef=useRef(performance.now()/1000); const viewOffsetRef=useRef(0);
        const drag=useRef({active:false,lastX:0,lastY:0,vx:0}); // Added lastY to initial state
        const nodes=useRef({}); const prevT=useRef(null);
        const history=useRef([]); const lastMidiRef=useRef(null); const midiSmoothRef=useRef(null); const lastManualScrollRef=useRef(0);
        const lockBuf=useRef([]); const glowMidiRef=useRef(null); const glowStrengthRef=useRef(0);
        const [noteText,setNoteText]=useState('—'); const [detuneText,setDetuneText]=useState('—'); 
        const [accPct,setAccPct]=useState(null); // Start with null instead of 0 - for bar width
        const [accPctText,setAccPctText]=useState(null); // Separate state for displayed text
        const [accColor,setAccColor]=useState(null);
        const [silenced, setSilenced] = useState(true); const silencedRef = useRef(true); const fadeTimerRef = useRef(0);
        const accSmoothRef = useRef(null); // Add smoothing for accuracy bar
        const accTextSmoothRef = useRef(null); // Separate smoothing for text display
        const [tauMs,setTauMs]=useState(0); const tauMsRef=useRef(0);
        const [linePx,setLinePx]=useState(2); const linePxRef=useRef(2);
        const [glowResp,setGlowResp]=useState(0); const glowRespRef=useRef(0.5);
        const [glowInt,setGlowInt]=useState(1.2); const glowIntRef=useRef(1.2);
        const [showGrades,setShowGrades]=useState(false); // Toggle for pitch grades
        const showGradesRef=useRef(false); // Ref for accessing in callback
        useEffect(()=>{showGradesRef.current=showGrades;},[showGrades]);
        const sectionsRef=useRef([]); // Store completed sections with grades
        const currentSectionRef=useRef(null); // Track current section being built
        
        // Note shape SVGs - one for each note (0=C, 1=C#, 2=D, etc.)
        const getNoteShape = (noteText) => {
          // Extract note name without octave (e.g., "B3" -> "B", "C#4" -> "C#")
          const noteName = noteText.replace(/[0-9]/g, '');
          const noteMap = {'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'A#':10, 'B':11};
          const pc = noteMap[noteName];
          if (pc === undefined) return <span className="inline-block h-6 w-6"/>; // Empty space for "—" or invalid
          const shapes = {
            0: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><circle cx="55.265" cy="55.265" r="55.265"/></svg>, // C - circle
            1: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m94.68,47.31c-3.92-4.88-8-9.52-12.48-13.58-7.8-7.08-14.99-13.88-20.88-23.36-1.94-3.12-3.98-7.16-6.05-10.35-2.07,3.19-4.11,7.22-6.05,10.35-5.89,9.48-13.08,16.28-20.88,23.36-4.48,4.06-8.56,8.71-12.48,13.58-7.17,8.92-7,28.08,2.53,37.28,8.97,8.66,21.88,9.37,30.55,1.16.79-.74,1.51-1.58,2.51-2.64-1.22,10.58-3.51,20.12-10.33,27.42h28.31c-6.82-7.3-9.11-16.84-10.33-27.42,1,1.05,1.72,1.89,2.51,2.64,8.67,8.21,21.58,7.5,30.55-1.16,9.53-9.2,9.7-28.36,2.53-37.28Z"/></svg>,
            2: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><rect x="0" y="0" width="110.53" height="110.53" /></svg>,
            3: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m55.26,110.53L0,55.26,55.26,0l55.26,55.26-55.26,55.26Z"/></svg>,
            4: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><polygon points="110.53 27.78 82.75 0 55.26 27.49 27.78 0 0 27.78 27.49 55.26 0 82.75 27.78 110.53 55.26 83.04 82.75 110.53 110.53 82.75 83.04 55.26 110.53 27.78"/></svg>,
            5: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m60.15,55.26c0-22.82,17.24-41.61,39.41-44.07C90.3,4.17,78.75,0,66.23,0,35.71,0,10.96,24.74,10.96,55.26s24.74,55.26,55.26,55.26c12.52,0,24.07-4.17,33.34-11.19-22.17-2.46-39.41-21.25-39.41-44.07Z"/></svg>,
            6: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m55.26,21.4C47.54-3.5,6.86-.54,6.86,30.67c0,28.39,48.4,75.12,48.4,75.12,0,0,48.4-46.73,48.4-75.12C103.66-.54,62.99-3.5,55.26,21.4Z"/></svg>,
            7: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><polygon points="55.26 2.7 72.34 37.31 110.53 42.86 82.89 69.79 89.42 107.82 55.26 89.87 21.11 107.82 27.63 69.79 0 42.86 38.19 37.31 55.26 2.7"/></svg>,
            8: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m106.26,25.03l.03-.07-.05.05c-1.84-1.47-4.17-2.36-6.71-2.36-5.93,0-10.74,4.81-10.74,10.74,0,2.24.69,4.32,1.86,6.04l-13.5,12.49-3.04-25.04c4.59-1.22,7.98-5.39,7.98-10.37,0-5.93-4.81-10.74-10.74-10.74s-10.74,4.81-10.74,10.74c0,3.85,2.04,7.22,5.08,9.12l-10.43,21.16-10.43-21.16c3.05-1.89,5.08-5.26,5.08-9.12,0-5.93-4.81-10.74-10.74-10.74s-10.74,4.81-10.74,10.74c0,4.97,3.39,9.15,7.98,10.37l-3.04,25.04-13.5-12.49c1.17-1.72,1.86-3.8,1.86-6.04,0-5.93-4.81-10.74-10.74-10.74-2.54,0-4.87.89-6.71,2.36l-.05-.05.03.07C1.82,27,.26,30.01.26,33.39c0,5.93,4.81,10.74,10.74,10.74.5,0,.98-.05,1.46-.11l15.65,36.28c-11.96,8.69-13.24,24.46-13.24,24.46h80.79s-1.27-15.77-13.24-24.46l15.65-36.28c.48.07.96.11,1.46.11,5.93,0,10.74-4.81,10.74-10.74,0-3.38-1.57-6.39-4.01-8.36Z"/></svg>,
            9: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><polygon points="55.26 2.7 0 42.86 21.11 107.82 89.42 107.82 110.53 42.86 55.26 2.7"/></svg>,
            10: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="m75.78,44.27c16.89-5.63,30.93,5.82,34.03,19.46,3.23,14.22-4.67,28.69-17.97,32.83-14.79,4.6-30.78-5.75-33.06-22.08-.13,6.64-.28,13.29,1.7,19.73,2.02,6.55,6.11,11.56,11.07,16.31h-32.17c-.12-.13-.25-.25-.37-.38.46-.35.97-.64,1.39-1.05,4.92-4.81,8.76-10.35,10.33-17.38,1.24-5.53,1.08-11.16.92-16.84-1.71,8.26-5.78,14.78-12.72,19.02-7.01,4.29-14.43,4.94-22.03,2C4.33,91.05-2.54,76.73.87,63.04c3.18-12.73,16.78-24.46,33.75-18.81-10.39-15.18-3.78-31.95,4.98-38.79,9.94-7.76,23.85-7.19,33.02,1.56,8.94,8.53,12.19,24.08,3.14,37.27Z"/></svg>,
            11: <svg className="h-6 w-auto" viewBox="0 0 110.53 110.53" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><polygon points="54.86 7.05 -.81 103.47 110.53 103.47 54.86 7.05"/></svg>
          };
          return shapes[pc];
        };
        
        const [settingsOpen,setSettingsOpen]=useState(false);
        const glowWinRef=useRef(0.4); const glowRampMsRef=useRef(120); const detTimerRef=useRef(0);
        const GAP_S = 0.30, GAP_PX = 30;
        const [lockTol, setLockTol] = useState(10); const lockTolRef = useRef(10);
        const lockRatioRef = useRef(0);
        const [lockWin, setLockWin] = useState(0.17);
        const [vibratoDetect,setVibratoDetect]=useState(0); const vibratoDetectRef=useRef(0);
        
        // Vibrato detection buffer for center-of-mass calculation
        const vibratoBufferRef = useRef([]);

        // === Init mic ===
        useEffect(()=>{(async()=>{ try{ const stream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false } }); await initNodes(stream);}catch(err){ console.warn(err); alert('Please allow microphone access (use HTTPS/localhost).'); } })();},[]);

        async function initNodes(stream){
          const old=nodes.current; if(old.stream){ old.stream.getTracks().forEach(t=>t.stop()); }
          const ctx = new (window.AudioContext||window.webkitAudioContext)();
          const src = ctx.createMediaStreamSource(stream);
          
          // Add gain node
          const gain = ctx.createGain();
          gain.gain.value = Math.pow(10, gainDbRef.current / 20); // Convert dB to linear
          
          const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=70; hp.Q.value=0.707;
          const analyser = ctx.createAnalyser(); analyser.fftSize=2048; analyser.smoothingTimeConstant = 0.2; 
          
          // Chain: src -> gain -> highpass -> analyser
          src.connect(gain).connect(hp).connect(analyser);
          
          nodes.current = { ctx, src, gain, analyser, buffer: new Float32Array(analyser.fftSize), stream };
          if(!prevT.current) requestAnimationFrame(loop);
        }

        // === Resize observer ===
        useEffect(()=>{
          const ro = new ResizeObserver(()=>{
            if(!containerRef.current) return;
            const railW=80; const {clientWidth:w, clientHeight:h} = containerRef.current;
            if(railRef.current){ railRef.current.width=railW; railRef.current.height=h; }
            if(gridRef.current){ gridRef.current.width=w-railW; gridRef.current.height=h; }
            if(traceRef.current){ traceRef.current.width=w-railW; traceRef.current.height=h; }
            drawRail(); drawGrid(scrollOffsetX.current);
          });
          if(containerRef.current) ro.observe(containerRef.current);
          return ()=> ro.disconnect();
        },[]);

        // === Scroll/zoom ===
        useEffect(()=>{
          const el = containerRef.current; if(!el) return;
          const onWheel=(e)=>{
            // Only handle actual wheel events, not touch gestures
            if(e.deltaMode === undefined) return;
            
            const nowS = performance.now()/1000; const horizIntent = e.shiftKey || Math.abs(e.deltaX)>Math.abs(e.deltaY);
            e.preventDefault();
            if(playingRef.current){
              const delta = e.deltaY;
              setCenterMidi(c=>{ const n=clamp(c + delta/(semitoneHRef.current*4), 36, 93); centerMidiRef.current=n; lastManualScrollRef.current = nowS; return n; });
            } else {
              if(horizIntent){ const d=(Math.abs(e.deltaX)>0?e.deltaX:e.deltaY); viewOffsetRef.current += d; drag.current.vx = d*0.5; }
              else { const delta=e.deltaY; setCenterMidi(c=>{ const n=clamp(c + delta/(semitoneHRef.current*4), 36, 93); centerMidiRef.current=n; lastManualScrollRef.current = nowS; return n; }); }
            }
          };
          el.addEventListener('wheel', onWheel, {passive:false});
          return ()=> el.removeEventListener('wheel', onWheel);
        },[]);

        // === Row-hold audition (sine) & drag panning ===
        useEffect(()=>{
          const surface = containerRef.current; if(!surface) return;
          const grid = gridRef.current;
          const rail = railRef.current;
          const trace = traceRef.current;
          if(!grid || !rail || !trace) return;

          function ensureSynth(){
            const N = nodes.current; const C = window.AudioContext || window.webkitAudioContext;
            let ctx = N.ctx; if(!ctx){ ctx = new C(); N.ctx = ctx; }
            try{ ctx.resume && ctx.resume(); }catch{}
            if(!N.synthGain){ const g = ctx.createGain(); g.gain.value = 0; g.connect(ctx.destination); N.synthGain = g; }
            if(!N.synthOsc){ const o = ctx.createOscillator(); o.type='sine'; o.frequency.value=440; o.connect(N.synthGain); o.start(); N.synthOsc = o; }
          }
          function setSynthFreq(freq){ const N=nodes.current; if(!N.ctx) return; ensureSynth(); const now=N.ctx.currentTime; N.synthOsc.frequency.setTargetAtTime(freq, now, 0.005); N.synthGain.gain.setTargetAtTime(0.15, now, 0.010); }
          function stopSynth(){ const N=nodes.current; if(!N.ctx||!N.synthGain) return; const now=N.ctx.currentTime; N.synthGain.gain.setTargetAtTime(0.0, now, 0.030); }

          // Check if a point is on the rail (piano keys) ONLY
          function isOnRail(clientX, clientY){
            const rect = rail.getBoundingClientRect();
            return clientX >= rect.left && clientX <= rect.right && 
                   clientY >= rect.top && clientY <= rect.bottom;
          }
          
          // Get MIDI from position on rail
          function getMidiFromRail(clientY){
            const rect = rail.getBoundingClientRect();
            const y = (clientY - rect.top) * (rail.height / rect.height);
            return Math.round(centerMidiRef.current - (y - (rail.height/2)) / semitoneHRef.current);
          }

          // Touch/mouse start
          const handleStart = (e) => {
            e.stopPropagation(); // Stop event bubbling
            const isTouch = e.type === 'touchstart';
            if(isTouch) e.preventDefault(); // Always prevent default on touch to stop iOS scroll
            
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            
            // Check if we're on the piano keys (rail only, not grid)
            if (isOnRail(clientX, clientY)) {
              // Start synth
              const midi = getMidiFromRail(clientY);
              if(midi && midi >= 36 && midi <= 93) {
                auditionRef.current = true;
                try { ensureSynth(); nodes.current.ctx?.resume?.(); } catch {}
                setSynthFreq(midiToFreq(midi));
              }
            } else if (!playingRef.current) {
              // Start dragging - touch anywhere else enables pan
              drag.current = { 
                active: true, 
                lastX: clientX, 
                lastY: clientY, 
                vx: 0 
              };
            }
          };

          // Touch/mouse move
          const handleMove = (e) => {
            e.stopPropagation();
            const isTouch = e.type === 'touchmove';
            if(isTouch) e.preventDefault();
            
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            
            if (auditionRef.current) {
              // Update synth if still on rail
              if(isOnRail(clientX, clientY)) {
                const midi = getMidiFromRail(clientY);
                if(midi && midi >= 36 && midi <= 93) {
                  setSynthFreq(midiToFreq(midi));
                }
              }
            } else if (drag.current.active && !playingRef.current) {
              // Pan the view
              const dx = clientX - drag.current.lastX;
              const dy = clientY - drag.current.lastY;
              
              // Horizontal scrolling
              viewOffsetRef.current += dx;
              drag.current.vx = dx;
              
              // Vertical scrolling - natural touch feel (swipe down = content moves down = pitch goes up)
              const pitchDelta = dy / (semitoneHRef.current * 2); // Reduced divisor for stronger scrolling
              setCenterMidi(c => { 
                const n = clamp(c + pitchDelta, 36, 93); 
                centerMidiRef.current = n; 
                return n; 
              });
              
              drag.current.lastX = clientX;
              drag.current.lastY = clientY;
            }
          };

          // Touch/mouse end
          const handleEnd = (e) => {
            e.stopPropagation();
            const isTouch = e.type.includes('touch');
            if(isTouch) e.preventDefault();
            
            if (auditionRef.current) {
              stopSynth();
              auditionRef.current = false;
            }
            
            drag.current.active = false;
          };

          // Add event listeners to ALL canvas elements to ensure touch events are captured
          const canvases = [rail, grid, trace];
          canvases.forEach(canvas => {
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleEnd, { passive: false });
            
            canvas.addEventListener('mousedown', handleStart);
          });
          
          // Mouse move and up on window for desktop
          window.addEventListener('mousemove', handleMove);
          window.addEventListener('mouseup', handleEnd);

          const onVis = () => { if (document.hidden) { stopSynth(); auditionRef.current = false; } };
          document.addEventListener('visibilitychange', onVis);

          return () => {
            canvases.forEach(canvas => {
              canvas.removeEventListener('touchstart', handleStart);
              canvas.removeEventListener('touchmove', handleMove);
              canvas.removeEventListener('touchend', handleEnd);
              canvas.removeEventListener('touchcancel', handleEnd);
              canvas.removeEventListener('mousedown', handleStart);
            });
            window.removeEventListener('mousemove', handleMove);
            window.removeEventListener('mouseup', handleEnd);
            document.removeEventListener('visibilitychange', onVis);
          };
        },[]);

        // === Sync to refs ===
        useEffect(()=>{ semitoneHRef.current = semitoneH; drawGrid(scrollOffsetX.current); drawRail(); }, [semitoneH]);
        useEffect(()=>{ widthPxRef.current = widthPx; }, [widthPx]);
        useEffect(()=>{ gainDbRef.current = gainDb; if(nodes.current.gain) nodes.current.gain.gain.value = Math.pow(10, gainDb / 20); }, [gainDb]);
        useEffect(()=>{ gateDbRef.current = gateDb; }, [gateDb]);
        useEffect(()=>{ centerMidiRef.current = centerMidi; }, [centerMidi]);
        useEffect(()=>{ glowWinRef.current = lockWin; }, [lockWin]);
        useEffect(()=>{ vibratoDetectRef.current = (vibratoDetect||0)/100; }, [vibratoDetect]);
        // keep lock tolerance ref in sync so retro trail + gauge react instantly
        useEffect(()=>{ lockTolRef.current = lockTol; }, [lockTol]);
        useEffect(()=>{ tauMsRef.current = tauMs; }, [tauMs]);
        useEffect(()=>{ linePxRef.current = linePx; }, [linePx]);
        useEffect(()=>{ glowIntRef.current = glowInt * 1.2; }, [glowInt]);
        useEffect(()=>{ playingRef.current = playing; }, [playing]);
        useEffect(()=>{ silencedRef.current = silenced; }, [silenced]);

        // === Drawing helpers ===
        const midiToY = (m,h)=> (h/2) + (centerMidiRef.current - m) * semitoneHRef.current;
        const yToMidi = (y,h)=> centerMidiRef.current - (y - (h/2)) / semitoneHRef.current;
        function hex(hex6,a){ const h=hex6.replace('#',''); const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16); return `rgba(${r},${g},${b},${a})`; }

        function drawRail(){
          const cvs=railRef.current; if(!cvs) return; const ctx=cvs.getContext('2d'); const w=cvs.width,h=cvs.height;
          ctx.clearRect(0,0,w,h); ctx.fillStyle='#0f0f13'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='#2a2a32';
          ctx.font='700 16px ui-sans-serif,system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
          const mStart=Math.max(36, Math.floor(centerMidiRef.current - h/(2*semitoneHRef.current))-2);
          const mEnd  =Math.min(93, Math.ceil (centerMidiRef.current + h/(2*semitoneHRef.current))+2);
          for(let m=mStart;m<=mEnd;m++){
            const cy=midiToY(m,h); const top=cy-semitoneHRef.current/2; const ht=semitoneHRef.current;
            ctx.fillStyle=isBlack(m)?'rgba(255,255,255,0.06)':'rgba(255,255,255,0.03)'; ctx.fillRect(0,top,w,ht);
            ctx.fillStyle='#d4d4d8'; ctx.fillText(midiToNoteName(m), w/2, cy);
            ctx.strokeStyle='#2a2a32'; ctx.beginPath(); ctx.moveTo(0, Math.round(top)+0.5); ctx.lineTo(w, Math.round(top)+0.5); ctx.stroke();
          }
        }

        function drawGrid(offsetX){
          const cvs=gridRef.current; if(!cvs) return; const ctx=cvs.getContext('2d'); const w=cvs.width,h=cvs.height;
          ctx.clearRect(0,0,w,h); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
          const mStart=Math.max(36, Math.floor(centerMidiRef.current - h/(2*semitoneHRef.current))-2);
          const mEnd  =Math.min(93, Math.ceil (centerMidiRef.current + h/(2*semitoneHRef.current))+2);
          for(let m=mStart;m<=mEnd;m++){
            const cy=midiToY(m,h); const top=cy-semitoneHRef.current/2; const ht=semitoneHRef.current;
            ctx.fillStyle=(m%2===0)?'#15161a':'#0e0e14'; ctx.fillRect(0,top,w,ht);
            ctx.strokeStyle='#30323a'; ctx.beginPath(); ctx.moveTo(0, Math.round(top)+0.5); ctx.lineTo(w, Math.round(top)+0.5); ctx.stroke();
            ctx.strokeStyle='#2b2d35'; ctx.beginPath(); ctx.moveTo(0, Math.round(cy)+0.5); ctx.lineTo(w, Math.round(cy)+0.5); ctx.stroke();
            if(glowMidiRef.current!==null && Math.round(glowMidiRef.current)===m && glowStrengthRef.current>0){
              const pc=((m%12)+12)%12; const col=NOTE_COLOR[pc];
              const g=ctx.createLinearGradient(0,top,0,top+ht);
              g.addColorStop(0, hex(col, 0.12*glowIntRef.current*glowStrengthRef.current));
              g.addColorStop(0.5, hex(col, 0.22*glowIntRef.current*glowStrengthRef.current));
              g.addColorStop(1, hex(col, 0.12*glowIntRef.current*glowStrengthRef.current));
              ctx.fillStyle=g; ctx.fillRect(0,top,w,ht);
              ctx.strokeStyle=hex(col,0.5*glowIntRef.current*glowStrengthRef.current);
              ctx.beginPath(); ctx.moveTo(0, Math.round(cy)+0.5); ctx.lineTo(w, Math.round(cy)+0.5); ctx.stroke();
            }
          }
          const step = widthPxRef.current, majorEvery=4; const start = -((offsetX)%step);
          for(let x=start; x<w; x+=step){ const idx=Math.round((x+offsetX)/step); const major=(idx%majorEvery)===0; ctx.strokeStyle=major?'#4b4b4b':'#2f2f2f'; ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,h); ctx.stroke(); }
        }

        // === Main loop ===
        function loop(t){
          const N=nodes.current; if(!N.analyser){ requestAnimationFrame(loop); return; }
          const trace=traceRef.current, grid=gridRef.current, rail=railRef.current; if(!trace||!grid||!rail){ requestAnimationFrame(loop); return; }
          const w=trace.width, h=trace.height; const headX=Math.floor(w*headFrac);

          const dt = prevT.current ? (t - prevT.current)/1000 : 0; prevT.current=t;
          N.analyser.getFloatTimeDomainData(N.buffer);
          let mean=0; for(let i=0;i<N.buffer.length;i++) mean+=N.buffer[i]; mean/=N.buffer.length;
          let e=0; for(let i=0;i<N.buffer.length;i++){ const v=N.buffer[i]-mean; e+=v*v; } const rmsNow=Math.sqrt(e/N.buffer.length);
          const dbInst = 20*Math.log10(Math.max(rmsNow,1e-8)); meterSmooth.current = meterSmooth.current*0.85 + dbInst*0.15; setMeterDb(meterSmooth.current);

          let zc=0; for(let i=1;i<N.buffer.length;i++){ const s0=N.buffer[i-1]-mean, s1=N.buffer[i]-mean; if((s0>=0)!==(s1>=0)) zc++; }
          const zcr = zc/(N.buffer.length-1);

          detTimerRef.current += dt; let freq=-1, confidence=0; if(detTimerRef.current >= 0.016){ const res = detectPitch(N.buffer, N.ctx.sampleRate, midiToFreq(36), midiToFreq(93)); freq = res.freq; confidence = res.confidence; detTimerRef.current = 0; }

          const gateOff = gateDbRef.current <= -70;
          const openThreshold = gateDbRef.current - 2;
          const aboveGate = gateOff || (meterSmooth.current >= openThreshold);

          // Check if we should be drawing/updating UI (same logic as line drawing)
          const shouldUpdate = freq > 0 && (confidence > 0.45 || (confidence > 0.30 && zcr < 0.18)) && aboveGate;

          if(playingRef.current){ scrollOffsetX.current += dt*widthPxRef.current; drawNowRef.current = performance.now()/1000; }
          else { 
            // Apply momentum only when there's actual velocity
            if(!drag.current.active && Math.abs(drag.current.vx) > 0.01){ 
              viewOffsetRef.current += drag.current.vx; 
              drag.current.vx *= 0.92; 
              if(Math.abs(drag.current.vx)<0.01) drag.current.vx=0; 
            } 
          }

          if(freq>0 && confidence>0.2){
            const rawMidi = freqToMidi(freq);
            
            // Update vibrato detection buffer
            const now = performance.now()/1000;
            vibratoBufferRef.current.push({t: now, midi: rawMidi});
            // Keep only last 300ms of samples
            while(vibratoBufferRef.current.length && now - vibratoBufferRef.current[0].t > 0.3) {
              vibratoBufferRef.current.shift();
            }
            
            // Calculate center of mass for vibrato detection
            let vibratoCenter = rawMidi;
            let isVibrato = false;
            if (vibratoDetectRef.current > 0 && vibratoBufferRef.current.length >= 10) {
              // Calculate average (center)
              const sum = vibratoBufferRef.current.reduce((a, s) => a + s.midi, 0);
              const center = sum / vibratoBufferRef.current.length;
              
              // Calculate deviations above and below center
              let maxAbove = 0, maxBelow = 0;
              vibratoBufferRef.current.forEach(s => {
                const dev = s.midi - center;
                if (dev > 0) maxAbove = Math.max(maxAbove, dev);
                else maxBelow = Math.max(maxBelow, Math.abs(dev));
              });
              
              // Check if oscillations are roughly symmetric (within 30% of each other)
              if (maxAbove > 0.1 && maxBelow > 0.1) {
                const ratio = Math.min(maxAbove, maxBelow) / Math.max(maxAbove, maxBelow);
                if (ratio > 0.7) {
                  isVibrato = true;
                  vibratoCenter = center;
                }
              }
            }
            
            // Apply smoothing ONLY for line drawing
            const tau = Math.max(0, (tauMsRef.current ?? 120));
            const alpha = (tau<=0 ? 1 : (1 - Math.exp(-Math.max(dt, 1/60) / (tau/1000))));
            midiSmoothRef.current = (midiSmoothRef.current==null) ? rawMidi : lerp(midiSmoothRef.current, rawMidi, alpha);
            const midi = midiSmoothRef.current;
            lastMidiRef.current = midi;

            // For accuracy display, use vibrato center if detected, otherwise raw
            const midiForAccuracy = isVibrato ? vibratoCenter : rawMidi;
            const nearestForAccuracy = Math.round(midiForAccuracy);
            const detForAccuracy = centsOff(midiToFreq(midiForAccuracy), midiToFreq(nearestForAccuracy));
            const absDetForAccuracy = Math.abs(detForAccuracy);
            
            // Calculate display values based on raw pitch (for responsiveness)
            const nearestRaw = Math.round(rawMidi);
            const detRaw = centsOff(freq, midiToFreq(nearestRaw));
            
            // Get tolerance value for use in multiple places
            const tolerance = lockTolRef.current ?? 10;
            
            // Accuracy calculation uses vibrato-adjusted value if enabled
            const maxCents = 50;
            const accPercent = Math.round(Math.max(0, Math.min(100, 100 * (1 - absDetForAccuracy / maxCents))));

            // Keep smoothed values for other uses
            const nearest = Math.round(midi);
            const target  = midiToFreq(nearest);
            const det     = centsOff(midiToFreq(midi), target);

            if (shouldUpdate) {
              // Direct updates with light smoothing for display stability
              fadeTimerRef.current = 0;
              setSilenced(false);
              setNoteText(midiToNoteName(nearestRaw));
              setDetuneText(`${detRaw>=0?'+':''}${detRaw.toFixed(0)}c`);
              
              // Apply smoothing to accuracy display with separate values for bar and text
              // Bar uses 0.2 for responsiveness, text uses 0.1 for readability
              if (accSmoothRef.current === null) {
                accSmoothRef.current = accPercent;
              } else {
                const smoothAlphaBar = 0.2;
                accSmoothRef.current = accSmoothRef.current * (1 - smoothAlphaBar) + accPercent * smoothAlphaBar;
              }
              const smoothedAcc = Math.round(accSmoothRef.current);
              setAccPct(smoothedAcc);
              
              // Smoother text display
              if (accTextSmoothRef.current === null) {
                accTextSmoothRef.current = accPercent;
              } else {
                const smoothAlphaText = 0.1;
                accTextSmoothRef.current = accTextSmoothRef.current * (1 - smoothAlphaText) + accPercent * smoothAlphaText;
              }
              const smoothedAccText = Math.round(accTextSmoothRef.current);
              setAccPctText(smoothedAccText);
              
              // Color changes based on smoothed accuracy crossing the threshold
              const thresholdPercent = 100 * (1 - tolerance / 50);
              if (smoothedAcc >= thresholdPercent) { 
                const pc=((nearestForAccuracy%12)+12)%12; 
                setAccColor(NOTE_COLOR[pc]); 
              } else { 
                setAccColor(null); 
              }
              
              // Section tracking for pitch grading (only if enabled and playing)
              if (showGradesRef.current && playingRef.current) {
                // Use vibrato center for more stable section detection
                const currentMidi = midiForAccuracy; // Uses vibrato center when detected
                const currentNote = Math.round(currentMidi);
                const MIN_SECTION_DURATION = 0.3; // seconds (reduced for more sensitivity)
                const STABILITY_TIME = 0.1; // seconds to confirm note change
                const NOTE_TOLERANCE = 0.4; // semitones tolerance for vibrato
                
                if (!currentSectionRef.current) {
                  // Start first section
                  currentSectionRef.current = {
                    note: currentNote,
                    centerMidi: currentMidi,
                    startTime: now,
                    midiSamples: [rawMidi], // Store raw MIDI for retrospective center calculation
                    color: NOTE_COLOR[((currentNote%12)+12)%12]
                  };
                } else {
                  const section = currentSectionRef.current;
                  
                  // Check if current pitch is close enough to section's center (handles vibrato)
                  const midiDiff = Math.abs(currentMidi - (section.centerMidi || section.note));
                  const isSameNote = midiDiff <= NOTE_TOLERANCE;
                  
                  if (isSameNote) {
                    // Same note (within vibrato tolerance), keep collecting samples
                    if (section.midiSamples.length < 1000) {
                      section.midiSamples.push(rawMidi);
                      section.lastSampleTime = now; // Track when last sample was added
                      // Update running center
                      section.centerMidi = (section.centerMidi || section.note) * 0.95 + currentMidi * 0.05;
                    }
                  } else {
                    // Note changed - check if it's stable
                    if (!section.changingTo) {
                      // First detection of change
                      section.changingTo = currentNote;
                      section.changeStartTime = now;
                    } else if (section.changingTo === currentNote) {
                      // Still changing to same new note
                      if (now - section.changeStartTime >= STABILITY_TIME) {
                        // Change is stable, finalize old section
                        // Use the time just before the change started as the end time
                        const duration = section.changeStartTime - section.startTime;
                        
                        if (duration >= MIN_SECTION_DURATION && section.midiSamples && section.midiSamples.length > 0) {
                          // Calculate center of all MIDI samples in this section
                          const midiSum = section.midiSamples.reduce((a,b)=>a+b, 0);
                          const midiCenter = midiSum / section.midiSamples.length;
                          const targetNote = Math.round(midiCenter);
                          
                          // Calculate accuracy based on how far the CENTER is from the target note
                          const maxCents = 50;
                          const centerCentsOff = (midiCenter - targetNote) * 100; // Convert semitones to cents
                          const absCenterCents = Math.abs(centerCentsOff);
                          const avgAcc = Math.round(Math.max(0, Math.min(100, 100 * (1 - absCenterCents / maxCents))));
                          
                          // Store all sections (temporarily removed 50% threshold for debugging)
                          sectionsRef.current.push({
                            note: targetNote,
                            startTime: section.startTime,
                            endTime: section.lastSampleTime || section.changeStartTime,
                            avgAccuracy: avgAcc,
                            color: NOTE_COLOR[((targetNote%12)+12)%12]
                          });
                          console.log('Section added:', avgAcc + '%', 'at note', targetNote, 'center:', midiCenter.toFixed(2), 'cents off:', centerCentsOff.toFixed(1), 'duration:', duration.toFixed(2) + 's');
                        } else {
                          console.log('Section rejected (too short):', 'duration:', duration.toFixed(2) + 's', 'samples:', section.midiSamples ? section.midiSamples.length : 0);
                        }
                        
                        // Start new section
                        currentSectionRef.current = {
                          note: currentNote,
                          startTime: now,
                          centerMidi: currentMidi,
                          midiSamples: [rawMidi],
                          color: NOTE_COLOR[((currentNote%12)+12)%12]
                        };
                      }
                    } else {
                      // Changed to different note, reset change detection
                      section.changingTo = currentNote;
                      section.changeStartTime = now;
                    }
                  }
                }
              }
            } else {
              fadeTimerRef.current += dt;
            }

            if (playingRef.current){
              const nowFollow = performance.now()/1000;
              if (nowFollow - lastManualScrollRef.current > 1.0){
                const visibleHalf = h / (2*semitoneHRef.current);
                const margin = 1.0;
                let targetCenter = centerMidiRef.current;
                if (midi > centerMidiRef.current + visibleHalf - margin) targetCenter = midi - (visibleHalf - margin);
                if (midi < centerMidiRef.current - visibleHalf + margin) targetCenter = midi + (visibleHalf - margin);
                if (targetCenter !== centerMidiRef.current){
                  const next = clamp(lerp(centerMidiRef.current, targetCenter, 0.10), 36, 93);
                  centerMidiRef.current = next; setCenterMidi(next);
                }
              }
            }

            // lock/glow update uses vibrato-adjusted midi when detected
            const midiForGlow = isVibrato && vibratoDetectRef.current > 0 ? vibratoCenter : midi;
            const nearestForGlow = Math.round(midiForGlow);
            const nowGlow = performance.now()/1000;
            lockBuf.current.push({t:nowGlow, nearest:nearestForGlow, cents:Math.abs((midiForGlow-nearestForGlow)*100), isVibrato});
            while(lockBuf.current.length && nowGlow-lockBuf.current[0].t>glowWinRef.current) lockBuf.current.shift();
            const same = lockBuf.current.filter(s=>s.nearest===nearestForGlow);
            const baseTol = (lockTolRef.current ?? 12);
            const within = same.filter(s=>s.cents < baseTol);
            const ratio = same.length ? within.length/same.length : 0;
            const need = (lockRatioRef.current ?? 0.0);
            const targetStrength = ratio>need ? Math.min(1, 0.8*ratio) : 0;
            const gamma = 1 - Math.exp(-Math.max(0, dt) / (glowRampMsRef.current/1000));
            glowStrengthRef.current = glowStrengthRef.current*(1-gamma) + targetStrength*gamma;
            glowMidiRef.current = glowStrengthRef.current>0.02?nearestForGlow:null;
          } else {
            // No valid pitch detected, start fading to silence
            fadeTimerRef.current += dt;
          }

          // Handle silence fade-out
          const FADE_TIME = 0.3; // 300ms fade time
          if (fadeTimerRef.current > FADE_TIME && !silencedRef.current) {
            setSilenced(true);
            setNoteText('—');
            setDetuneText('—'); 
            setAccColor(null);
            setAccPct(null); // Set to null instead of 0
            setAccPctText(null); // Reset text display too
            accSmoothRef.current = null; // Reset smoothing
            accTextSmoothRef.current = null; // Reset text smoothing
            
            // Finalize any open section when going silent
            if (showGradesRef.current && currentSectionRef.current) {
              const section = currentSectionRef.current;
              const now = performance.now()/1000;
              const duration = (section.lastSampleTime || now) - section.startTime;
              const MIN_SECTION_DURATION = 0.3;
              
              if (duration >= MIN_SECTION_DURATION && section.midiSamples && section.midiSamples.length > 0) {
                // Calculate center of all MIDI samples in this section
                const midiSum = section.midiSamples.reduce((a,b)=>a+b, 0);
                const midiCenter = midiSum / section.midiSamples.length;
                const targetNote = Math.round(midiCenter);
                
                // Calculate accuracy based on how far the CENTER is from the target note
                const maxCents = 50;
                const centerCentsOff = (midiCenter - targetNote) * 100;
                const absCenterCents = Math.abs(centerCentsOff);
                const avgAcc = Math.round(Math.max(0, Math.min(100, 100 * (1 - absCenterCents / maxCents))));
                
                sectionsRef.current.push({
                  note: targetNote,
                  startTime: section.startTime,
                  endTime: section.lastSampleTime || now,
                  avgAccuracy: avgAcc,
                  color: NOTE_COLOR[((targetNote%12)+12)%12]
                });
                console.log('Section finalized on silence:', avgAcc + '%', 'at note', targetNote, 'center:', midiCenter.toFixed(2), 'cents off:', centerCentsOff.toFixed(1), 'duration:', duration.toFixed(2) + 's');
              }
              
              // Clear current section
              currentSectionRef.current = null;
            }
          }

          if(playingRef.current && freq>0 && (confidence>0.45 || (confidence>0.30 && zcr<0.18)) && aboveGate){ 
            const now=performance.now()/1000; 
            // Calculate vibrato center for history storage
            let histVibCenter = null;
            if (vibratoDetectRef.current > 0 && vibratoBufferRef.current.length >= 10) {
              const sum = vibratoBufferRef.current.reduce((a, s) => a + s.midi, 0);
              const center = sum / vibratoBufferRef.current.length;
              let maxAbove = 0, maxBelow = 0;
              vibratoBufferRef.current.forEach(s => {
                const dev = s.midi - center;
                if (dev > 0) maxAbove = Math.max(maxAbove, dev);
                else maxBelow = Math.max(maxBelow, Math.abs(dev));
              });
              if (maxAbove > 0.1 && maxBelow > 0.1) {
                const ratio = Math.min(maxAbove, maxBelow) / Math.max(maxAbove, maxBelow);
                if (ratio > 0.7) histVibCenter = center;
              }
            }
            const mm = lastMidiRef.current ?? freqToMidi(freq); 
            const near = Math.round(mm); 
            tryWriteHistory({t:now, midi:mm, vibCenter: histVibCenter, g: glowStrengthRef.current, nearest: near}); 
            const cutoff=now-RETAIN_SEC; 
            while(history.current.length && history.current[0].t<cutoff) history.current.shift(); 
          }

          drawGrid(scrollOffsetX.current); drawRail();

          const ctx=trace.getContext('2d'); ctx.clearRect(0,0,w,h);
          ctx.strokeStyle='rgba(241,245,249,0.2)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(headX+0.5,0); ctx.lineTo(headX+0.5,h); ctx.stroke();
          const refNow = playingRef.current ? performance.now()/1000 : drawNowRef.current;

          // retroactive accuracy glow trail
          ctx.save();
          for (let i = 1; i < history.current.length; i++) {
            const p0 = history.current[i - 1], p1 = history.current[i]; if (!p0 || !p1) continue;
            const segDt = p1.t - p0.t; const isGapSeg = (segDt > GAP_S) || (segDt * widthPxRef.current > GAP_PX); if (isGapSeg) continue;
            
            // Use vibrato center if available and enabled
            const midi0 = (p0.vibCenter && vibratoDetectRef.current > 0) ? p0.vibCenter : p0.midi;
            const midi1 = (p1.vibCenter && vibratoDetectRef.current > 0) ? p1.vibCenter : p1.midi;
            
            const row0 = Math.round(midi0), row1 = Math.round(midi1); 
            if (row0 !== row1) continue; 
            const row = row0;
            
            const win = glowWinRef.current; 
            let same = 0, within = 0;
            for (let k = i; k >= 0; k--) { 
              const q = history.current[k]; 
              if (!q) break; 
              const dt = p1.t - q.t; 
              if (dt > win) break; 
              const qMidi = (q.vibCenter && vibratoDetectRef.current > 0) ? q.vibCenter : q.midi;
              if (Math.round(qMidi) !== row) continue; 
              same++; 
              const cents = Math.abs((qMidi - row) * 100); 
              if (cents < (lockTolRef.current ?? 12)) within++; 
            }
            
            const ratio = same ? within / same : 0; 
            const g = ratio > 0 ? Math.min(1, 0.8 * ratio) : 0; 
            if (g <= 0) continue;
            
            const x0 = headX + (playingRef.current ? 0 : viewOffsetRef.current) - (refNow - p0.t) * widthPxRef.current;
            const x1 = headX + (playingRef.current ? 0 : viewOffsetRef.current) - (refNow - p1.t) * widthPxRef.current; 
            if (x1 < 0 || x0 > w) continue;
            
            // Use display row (not vibrato center) for visual position
            const displayRow = Math.round(p0.midi);
            const cy = midiToY(displayRow, h); 
            const top = cy - semitoneHRef.current / 2, ht = semitoneHRef.current; 
            const segW = Math.max(1, x1 - x0);
            const pc = ((row % 12) + 12) % 12; 
            const col = NOTE_COLOR[pc];
            
            ctx.save(); 
            ctx.beginPath(); 
            ctx.rect(x0, top, segW, ht); 
            ctx.clip();
            
            const band = ctx.createLinearGradient(0, top, 0, top + ht); 
            const TRAIL_GAIN = 3; 
            const aEdge = 0.14 * TRAIL_GAIN * g * glowIntRef.current; 
            const aMid  = 0.28 * TRAIL_GAIN * g * glowIntRef.current;
            band.addColorStop(0,   hex(col, aEdge)); 
            band.addColorStop(0.5, hex(col, aMid)); 
            band.addColorStop(1,   hex(col, aEdge));
            ctx.fillStyle = band; 
            ctx.fillRect(x0, top, segW, ht);
            ctx.strokeStyle = hex(col, 0.45 * TRAIL_GAIN * g * glowIntRef.current); 
            ctx.beginPath(); 
            ctx.moveTo(x0, Math.round(cy) + 0.5); 
            ctx.lineTo(x1, Math.round(cy) + 0.5); 
            ctx.stroke();
            ctx.restore();
          }
          ctx.restore();

          ctx.lineWidth = linePxRef.current; ctx.strokeStyle='#f1f5f9'; ctx.lineCap='round'; ctx.lineJoin='round';
          let moved = false; let prev = null; ctx.beginPath();
          for(let i=0;i<history.current.length;i++){
            const p = history.current[i]; const age = refNow - p.t;
            const x = headX + (playingRef.current?0:viewOffsetRef.current) - age*widthPxRef.current; if(x < 0) continue;
            const y = midiToY(p.midi, h);
            const isGap = prev && (((p.t - prev.t) > GAP_S) || ((p.t - prev.t) * widthPxRef.current > GAP_PX));
            if(!moved || isGap){ ctx.moveTo(x, y); moved = true; } else{ ctx.lineTo(x, y); }
            prev = p;
          }
          if(moved) ctx.stroke();
          
          // Draw pitch grades if enabled
          if(showGradesRef.current && sectionsRef.current.length > 0){
            ctx.font = '700 14px ui-sans-serif,system-ui';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillStyle = '#ffffff';
            
            // For each section, find the history point closest to its end time
            for(let i=0; i<sectionsRef.current.length; i++){
              const section = sectionsRef.current[i];
              
              // Find the history point at or just after section end
              let closestPoint = null;
              let minDiff = Infinity;
              for(let j=0; j<history.current.length; j++){
                const p = history.current[j];
                const diff = Math.abs(p.t - section.endTime);
                if(diff < minDiff && Math.round(p.midi) === section.note){
                  minDiff = diff;
                  closestPoint = p;
                }
              }
              
              if(closestPoint){
                const age = refNow - closestPoint.t;
                const x = headX + (playingRef.current?0:viewOffsetRef.current) - age*widthPxRef.current;
                
                // Only draw if on screen
                if(x >= 0 && x <= w){
                  const y = midiToY(section.note, h) - 15;
                  ctx.fillText(`${section.avgAccuracy}%`, x, y);
                }
              }
            }
          }

          const headMidi = lastMidiRef.current??centerMidiRef.current; const headY = midiToY(headMidi,h); ctx.beginPath(); ctx.arc(headX, headY, 3, 0, Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();

          requestAnimationFrame(loop);
        }

        function tryWriteHistory(obj){
          try{
            const midi = (obj && (obj.midi ?? obj.m ?? obj.noteMidi ?? obj.mid ?? obj.val));
            const vibCenter = obj?.vibCenter ?? null;
            const c = (obj?.conf ?? obj?.confidence ?? obj?.c ?? 1);
            if(!Number.isFinite(midi)) return; if(!(c > 0.2)) return; if(midi < 36 || midi > 93) return;
            const last = history.current[history.current.length-1];
            if(last && Number.isFinite(last.midi)){
              const dt = (obj.t ?? 0) - last.t; const dm = Math.abs(midi - last.midi);
              const tThresh = 0.3/Math.max(20, widthPxRef.current); const mThresh = 0.06; if(dt < tThresh && dm < mThresh) return;
            }
            history.current.push({ t: (obj.t ?? performance.now()/1000), midi, vibCenter, row: (obj.nearest ?? Math.round(midi)) });
          } catch(err){ }
        }

        // === UI ===
        // Mobile Layout
        if (isMobile) {
          return (
            <div className="w-full h-full flex flex-col select-none bg-[#0b0f14]">
              {/* Mobile Header */}
              <div className="flex items-start gap-4 px-4 py-3 border-b border-zinc-800 bg-[#0e0e14]">
                <div className="flex-none" style={{width: '100px'}}>
                  <div className="text-xs text-zinc-500 mb-1">Current Note</div>
                  <div className="flex items-center gap-2" style={{ color: silenced ? '#71717a' : (accColor || '#9ca3af') }}>
                    {getNoteShape(noteText)}
                    <div className={`text-2xl font-semibold ${silenced ? 'text-zinc-600' : ''}`}>
                      {noteText}
                    </div>
                  </div>
                </div>
                
                <div className="flex-1 min-w-0 flex flex-col justify-between" style={{height: '44px'}}>
                  <div className="text-xs text-zinc-500 text-right">Accuracy</div>
                  <div className="flex items-center gap-1.5">
                    <div className="relative flex-1 min-w-0">
                      <div className="h-5 rounded-full overflow-hidden bg-zinc-800 relative">
                        <div className="h-full rounded-full" 
                             style={{width:`${accPct ?? 0}%`, background: silenced ? '#71717a' : (accColor||'#71717a')}}></div>
                      </div>
                      <div className="absolute top-0 left-0 right-0 h-5 pointer-events-none flex items-center">
                        <div className="w-[2px] h-full bg-white/30" 
                             style={{marginLeft: `calc(${100 * (1 - lockTol / 50)}% - 1px)`}}/>
                      </div>
                    </div>
                    <div className="text-xs text-zinc-400 tabular-nums w-8 text-right flex-none">{accPctText ?? 0}%</div>
                  </div>
                </div>
              </div>

              {/* Main Canvas Area */}
              <div ref={containerRef} className="flex-1 relative grid grid-cols-[60px,1fr]" 
                   style={{overscrollBehavior:'contain', touchAction:'none'}}>
                <canvas ref={railRef} className="h-full w-[60px]" style={{touchAction:'none'}}></canvas>
                <div className="relative h-full" style={{touchAction:'none'}}>
                  <canvas ref={gridRef} className="absolute inset-0" style={{touchAction:'none'}}></canvas>
                  <canvas ref={traceRef} className="absolute inset-0" style={{touchAction:'none'}}></canvas>
                </div>
              </div>

              {/* Gain/Gate Controls - Single Row */}
              <div className="px-4 py-3 border-t border-zinc-800 bg-[#0e0e14]">
                <div className="flex items-center gap-4">
                  <div className="flex-1 flex items-center gap-2">
                    <span className="text-xs text-zinc-400">Gain</span>
                    <div className="flex-1 relative">
                      <input type="range" min="-30" max="30" step="1" value={gainDb} 
                             onChange={(e)=>{ const v=parseInt(e.target.value); gainDbRef.current=v; setGainDb(v); }} 
                             className="w-full gain" 
                             style={{ '--gain-bg': gainBg }} />
                    </div>
                    <span className="text-xs text-zinc-400 tabular-nums w-10 text-right">
                      {gainDb>=0?'+':''}{gainDb}{isMobile ? '' : ' db'}
                    </span>
                  </div>
                  
                  <div className="flex-1 flex items-center gap-2">
                    <span className="text-xs text-zinc-400">Gate</span>
                    <div className="flex-1 relative">
                      <input type="range" min="-80" max="-5" step="1" value={gateDb} 
                             onChange={(e)=>{ const v=parseInt(e.target.value); gateDbRef.current=v; setGateDb(v); }} 
                             className="w-full ngate" 
                             style={{ 
                               '--ngate-bg': gateBg,
                               WebkitAppearance: 'none',
                               appearance: 'none',
                               background: 'transparent',
                               height: '20px'
                             }} />
                    </div>
                    <span className="text-xs text-zinc-400 tabular-nums w-10 text-right">
                      {gateDb}{isMobile ? '' : ' db'}
                    </span>
                  </div>
                </div>
              </div>

              {/* Bottom Navigation */}
              <div className="flex items-center justify-around py-3 border-t border-zinc-800 bg-[#0e0e14]">
                <button onClick={()=>setSettingsOpen(!settingsOpen)} 
                        className="p-3 rounded-2xl bg-zinc-900/50 border border-zinc-700">
                  <svg className="w-6 h-6 fill-zinc-300" viewBox="0 0 24 24">
                    <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5a3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.65-.07-.97l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.32-.07.64-.07.97c0 .33.03.65.07.97l-2.11 1.63c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.39 1.06.73 1.69.98l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.25 1.17-.59 1.69-.98l2.49 1c.22.08.49 0 .61-.22l2-3.46c.13-.22.07-.49-.12-.64l-2.11-1.63Z"/>
                  </svg>
                </button>
                
                <button onClick={()=>{ 
                  if (!playingRef.current) { 
                    const now = performance.now()/1000; 
                    const pausedGap = Math.max(0, now - drawNowRef.current); 
                    if (pausedGap > 0) { 
                      for (let i=0;i<history.current.length;i++){ history.current[i].t += pausedGap; } 
                      for (let i=0;i<lockBuf.current.length;i++){ lockBuf.current[i].t += pausedGap; } 
                    } 
                    viewOffsetRef.current = 0; 
                    drawNowRef.current = now; 
                    drag.current.vx = 0; 
                    setPlaying(true);
                  } else { 
                    setPlaying(false);
                  } 
                }} 
                className="relative h-16 w-20 rounded-2xl bg-[#15151b] border border-white/10 shadow-inner">
                  <div className="absolute inset-0 rounded-2xl ring-1 ring-black/30 pointer-events-none"></div>
                  <div className="flex items-center justify-center h-full">
                    {playing ? (
                      <div className="flex gap-1.5">
                        <span className="block h-8 w-2 bg-zinc-200 rounded"/>
                        <span className="block h-8 w-2 bg-zinc-200 rounded"/>
                      </div>
                    ) : (
                      <svg viewBox="0 0 24 24" className="h-10 w-10 fill-zinc-200">
                        <path d="M8 5v14l11-7z"/>
                      </svg>
                    )}
                  </div>
                </button>
                
                <button onClick={()=>{ 
                  history.current=[]; 
                  sectionsRef.current=[]; 
                  currentSectionRef.current=null;
                  lockBuf.current=[]; 
                  glowMidiRef.current=null; 
                  glowStrengthRef.current=0; 
                }} 
                className="px-4 py-3 rounded-2xl bg-zinc-900/50 border border-zinc-700 text-zinc-300 text-sm">
                  Clear
                </button>
              </div>

              {/* Mobile Settings Panel (slides up from bottom) */}
              {settingsOpen && (
                <div className="fixed inset-0 bg-black/50 z-50" onClick={()=>setSettingsOpen(false)}>
                  <div className="absolute bottom-0 left-0 right-0 bg-[#15151b] rounded-t-3xl border-t border-zinc-700 max-h-[80vh] overflow-y-auto"
                       onClick={(e)=>e.stopPropagation()}>
                    <div className="p-6">
                      <div className="w-12 h-1 bg-zinc-600 rounded-full mx-auto mb-6"/>
                      
                      <div className="space-y-5">
                        {/* Height and Width side-by-side */}
                        <div className="grid grid-cols-2 gap-3">
                          <div>
                            <div className="flex justify-between items-center mb-2">
                              <span className="text-sm text-zinc-300">Height</span>
                              <span className="text-sm text-zinc-400">{semitoneH} px</span>
                            </div>
                            <input type="range" min="16" max="64" step="1" value={semitoneH} 
                                   onChange={(e)=>{ const n=parseInt(e.target.value); semitoneHRef.current=n; setSemitoneH(n); }} 
                                   className="w-full"/>
                          </div>
                          
                          <div>
                            <div className="flex justify-between items-center mb-2">
                              <span className="text-sm text-zinc-300">Width</span>
                              <span className="text-sm text-zinc-400">{widthPx} px</span>
                            </div>
                            <input type="range" min="20" max="140" step="1" value={widthPx} 
                                   onChange={(e)=>{ const n=parseInt(e.target.value); setWidthPx(n); widthPxRef.current=n; }} 
                                   className="w-full"/>
                          </div>
                        </div>
                        
                        {/* Divider */}
                        <div className="border-t border-zinc-700"></div>
                        
                        <div>
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-zinc-300">Accuracy Goal</span>
                            <span className="text-sm text-zinc-400">{100 - lockTol}%</span>
                          </div>
                          <input type="range" min="5" max="30" step="1" value={lockTol} 
                                 onChange={(e)=>setLockTol(parseInt(e.target.value))} 
                                 className="w-full"/>
                        </div>
                        
                        {/* Line Thickness - commented out but available to restore later
                        <div>
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-zinc-300">Line Thickness</span>
                            <span className="text-sm text-zinc-400">{linePx} px</span>
                          </div>
                          <input type="range" min="1" max="6" step="1" value={linePx} 
                                 onChange={(e)=>setLinePx(parseInt(e.target.value))} 
                                 className="w-full"/>
                        </div>
                        */}
                        
                        <div>
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-zinc-300">Glow Intensity</span>
                            <span className="text-sm text-zinc-400">{Math.round(glowInt*100)}%</span>
                          </div>
                          <input type="range" min="0.5" max="2" step="0.01" value={glowInt} 
                                 onChange={(e)=>setGlowInt(parseFloat(e.target.value))} 
                                 className="w-full"/>
                        </div>
                        
                        <div>
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-zinc-300">Glow Blending</span>
                            <span className="text-sm text-zinc-400">{Math.round(lockWin*1000)} ms</span>
                          </div>
                          <input type="range" min="80" max="600" step="10" value={Math.round(lockWin*1000)} 
                                 onChange={(e)=>setLockWin(parseInt(e.target.value)/1000)} 
                                 className="w-full"/>
                        </div>

                        {/* Signal Smoothing - commented out but available to restore later
                        <div>
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-zinc-300">Signal Smoothing</span>
                            <span className="text-sm text-zinc-400">{tauMs} ms</span>
                          </div>
                          <input type="range" min="0" max="30" step="1" value={tauMs} 
                                 onChange={(e)=>setTauMs(parseInt(e.target.value))} 
                                 className="w-full"/>
                        </div>
                        */}
                        
                        <div className="border-t border-zinc-700 pt-4 mt-4">
                          <div className="flex items-center justify-between mb-2">
                            <span className="text-sm text-zinc-300">Show pitch grades</span>
                            <label className="relative inline-flex items-center cursor-pointer">
                              <input type="checkbox" checked={showGrades} onChange={(e)=>setShowGrades(e.target.checked)} className="sr-only peer"/>
                              <div className="w-9 h-5 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                          </div>
                          <div className="text-xs text-zinc-500">
                            Display average accuracy percentage above completed pitch sections
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        }

        // Desktop Layout (original)
        return (
          <div className="w-full h-full flex flex-col select-none">
            {/* Header */}
            <div className="flex items-center justify-between px-4 py-4 border-b border-zinc-800 bg-[#0e0e14]/80">
              <div className="flex items-center gap-4">
                <div className="flex items-center gap-8 ml-4">
                  <button onClick={async()=>{try{const ctx = nodes.current.ctx || new (window.AudioContext||window.webkitAudioContext)(); nodes.current.ctx = ctx; await ctx.resume?.(); const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false}}); if(nodes.current.stream){ try{ nodes.current.stream.getTracks().forEach(t=>t.stop()); }catch{} } nodes.current.stream = stream; const source = ctx.createMediaStreamSource(stream); const gain = ctx.createGain(); gain.gain.value = Math.pow(10, gainDbRef.current / 20); const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=70; hp.Q.value=0.707; const analyser = nodes.current.analyser || ctx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.2; nodes.current.analyser = analyser; nodes.current.buffer = new Float32Array(analyser.fftSize); source.connect(gain).connect(hp).connect(analyser); nodes.current.src = source; nodes.current.gain = gain; }catch(err){ console.error('Mic reconnect failed', err); } }} className="px-4 py-2 rounded-2xl bg-zinc-900 border border-zinc-700 text-zinc-200 hover:bg-zinc-800">Microphone</button>
                  
                  {/* Input Gain and Noise Gate column */}
                  <div className="flex flex-col gap-1">
                    <div className="grid items-center gap-3" style={{gridTemplateColumns:'80px 104px auto'}}>
                      <div className="text-xs text-zinc-400 text-right">Input Gain</div>
                      <input type="range" min="-30" max="30" step="1" value={gainDb} onChange={(e)=>{ const v=parseInt(e.target.value); gainDbRef.current=v; setGainDb(v); }} className="w-[104px] justify-self-center gain appearance-none" style={{ '--gain-bg': gainBg }} />
                      <div className="text-xs text-zinc-400 tabular-nums">{gainDb>=0?'+':''}{gainDb}{isMobile ? '' : ' dB'}</div>
                    </div>
                    <div className="grid items-center gap-3" style={{gridTemplateColumns:'80px 104px auto'}}>
                      <div className="text-xs text-zinc-400 text-right">Noise Gate</div>
                      <input type="range" min="-80" max="-5" step="1" value={gateDb} onChange={(e)=>{ const v=parseInt(e.target.value); gateDbRef.current=v; setGateDb(v); }} className="w-[104px] justify-self-center ngate appearance-none" style={{ '--ngate-bg': gateBg }} />
                      <div className="text-xs text-zinc-400 tabular-nums">{gateDb}{isMobile ? '' : ' dB'}{gateDb<=-70? ' (off)':''}</div>
                    </div>
                  </div>
                  
                  {/* Height/Width column */}
                  <div className="hidden md:grid items-center gap-2" style={{gridTemplateColumns:'80px 104px 28px'}}>
                    <div className="text-xs text-zinc-400 text-right">Height</div>
                    <input type="range" min="16" max="64" step="1" value={semitoneH} className="w-[104px] justify-self-center"
                      onChange={(e)=>{ const n=parseInt(e.target.value); semitoneHRef.current=n; setSemitoneH(n); }} />
                    <div className="text-xs text-zinc-400 tabular-nums text-right">{semitoneH}px</div>

                    <div className="text-xs text-zinc-400 text-right">Width</div>
                    <input type="range" min="20" max="140" step="1" value={widthPx} className="w-[104px] justify-self-center"
                      onChange={(e)=>{ const n=parseInt(e.target.value); setWidthPx(n); widthPxRef.current=n; }} />
                    <div className="text-xs text-zinc-400 tabular-nums text-right">{widthPx}px</div>
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-6">
                {/* Play/Pause */}
                <button onClick={()=>{ if (!playingRef.current) { const now = performance.now()/1000; const pausedGap = Math.max(0, now - drawNowRef.current); if (pausedGap > 0) { for (let i=0;i<history.current.length;i++){ history.current[i].t += pausedGap; } for (let i=0;i<lockBuf.current.length;i++){ lockBuf.current[i].t += pausedGap; } } viewOffsetRef.current = 0; drawNowRef.current = now; drag.current.vx = 0; setPlaying(true);} else { setPlaying(false);} }} className="group relative h-12 w-20 rounded-2xl bg-[#15151b] border border-white/10 shadow-inner hover:border-white/20 transition" aria-label={playingRef.current? 'Pause':'Play'}>
                  <div className="absolute inset-0 rounded-2xl ring-1 ring-black/30 pointer-events-none"></div>
                  <div className="flex items-center justify-center h-full">
                    {playing ? (
                      <div className="flex gap-1.5"><span className="block h-8 w-2 bg-zinc-200 rounded"/><span className="block h-8 w-2 bg-zinc-200 rounded"/></div>
                    ) : (
                      <svg viewBox="0 0 24 24" className="h-10 w-10 fill-zinc-200"><path d="M8 5v14l11-7z"/></svg>
                    )}
                  </div>
                </button>
                <button onClick={()=>{ history.current=[]; sectionsRef.current=[]; currentSectionRef.current=null; lockBuf.current=[]; glowMidiRef.current=null; glowStrengthRef.current=0; vibratoBufferRef.current=[]; }} className="px-4 py-2 rounded-2xl bg-[#15151b] border border-white/10 text-zinc-300 hover:border-white/20">Clear History</button>

                {/* Current Note */}
                <div className="flex flex-col items-center min-w-[140px]">
                  <div className={`text-xs ${silenced ? 'text-zinc-600' : 'text-zinc-400'}`}>Current Note</div>
                  <div className="flex items-center gap-2 mt-1" style={{ color: silenced ? '#71717a' : (accColor || '#9ca3af') }}>
                    {getNoteShape(noteText)}
                    <div className={`text-3xl font-semibold tracking-wide ${silenced ? 'text-zinc-600' : ''}`}>{noteText}</div>
                  </div>
                </div>

                {/* Accuracy */}
                <div className="flex flex-col items-center">
                  <div className={`text-xs ${silenced ? 'text-zinc-600' : 'text-zinc-400'}`}>Accuracy</div>
                  <div className="w-64 mt-2">
                    <div className={`h-3 rounded overflow-hidden relative ${silenced ? 'bg-zinc-800' : 'bg-zinc-800'}`}>
                      <div className="h-full rounded" style={{width:`${accPct ?? 0}%`, background: silenced ? '#71717a' : (accColor||'#71717a')}}></div>
                      {/* Lock tolerance threshold line - always visible */}
                      <div 
                        className="absolute top-0 h-full w-[2px] bg-white/50" 
                        style={{
                          left: `${100 * (1 - lockTol / 50)}%`
                        }}
                      />
                    </div>
                    <div className={`text-center text-xs mt-1 ${silenced ? 'text-zinc-600' : 'text-zinc-400'}`}>{accPctText ?? 0}%</div>
                  </div>
                </div>

                {/* Detune */}
                <div className="flex flex-col items-center min-w-[100px]">
                  <div className={`text-xs ${silenced ? 'text-zinc-600' : 'text-zinc-400'}`}>Detune</div>
                  <div className={`text-2xl font-semibold tracking-wide mt-1 ${silenced ? 'text-zinc-600' : ''}`}>{detuneText}</div>
                </div>
              </div>

              <div className="relative w-12 flex justify-end">
                <button onClick={()=>setSettingsOpen(v=>!v)} className="group relative h-12 w-12 rounded-2xl bg-[#15151b] border border-white/10 shadow-inner hover:border-white/20 transition" aria-label="Settings">
                  <div className="absolute inset-0 rounded-2xl ring-1 ring-black/30 pointer-events-none"></div>
                  <div className="flex items-center justify-center h-full">
                    <span className="text-2xl leading-none text-zinc-200 select-none">⚙</span>
                  </div>
                </button>
                {settingsOpen && (
                  <>
                    {/* Backdrop */}
                    <div className="fixed inset-0 bg-black/50 z-40" onClick={()=>setSettingsOpen(false)} style={{touchAction: 'none'}}></div>
                    
                    {/* Settings Panel */}
                    <div className={`${isMobile ? 'fixed bottom-0 left-0 right-0 rounded-t-3xl max-h-[70vh] overflow-y-auto' : 'absolute right-0 top-12 w-72 rounded-2xl'} z-50 border border-white/10 bg-[#15151b] shadow-xl p-4`} style={isMobile ? {touchAction: 'pan-y'} : {}}>
                    <div className="text-sm text-zinc-300 font-medium mb-3">Tuning Settings</div>
                    <div className="space-y-4">
                      {/* Signal Smoothing - commented out but available to restore later
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Signal smoothing</span><span>{tauMs} ms</span></div>
                        <input type="range" min="0" max="30" step="1" value={tauMs} onChange={(e)=>setTauMs(parseInt(e.target.value))} className="w-full"/>
                      </div>
                      */}
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Accuracy goal</span><span>{100 - lockTol}%</span></div>
                        <input type="range" min="5" max="30" step="1" value={lockTol} onChange={(e)=>setLockTol(parseInt(e.target.value))} className="w-full"/>
                      </div>
                      {/* Line Thickness - commented out but available to restore later
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Line thickness</span><span>{linePx} px</span></div>
                        <input type="range" min="1" max="6" step="1" value={linePx} onChange={(e)=>setLinePx(parseInt(e.target.value))} className="w-full"/>
                      </div>
                      */}
                      {/* Glow Responsiveness - commented out but available to restore later
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Glow responsiveness</span><span>{Math.round(glowWinRef.current*1000)} ms / {glowRampMsRef.current} ms</span></div>
                        <input type="range" min="0" max="1" step="0.01" value={glowResp} onChange={(e)=>setGlowResp(parseFloat(e.target.value))} className="w-full"/>
                      </div>
                      */}
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Glow intensity</span><span>{Math.round(glowInt*100)}%</span></div>
                        <input type="range" min="0.5" max="2" step="0.01" value={glowInt} onChange={(e)=>setGlowInt(parseFloat(e.target.value))} className="w-full"/>
                      </div>
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Glow blending</span><span>{Math.round(lockWin*1000)} ms</span></div>
                        <input type="range" min="80" max="600" step="10" value={Math.round(lockWin*1000)} onChange={(e)=>setLockWin(parseInt(e.target.value)/1000)} className="w-full"/>
                      </div>
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400"><span>Vibrato detection</span><span>{vibratoDetect}%</span></div>
                        <input type="range" min="0" max="100" step="10" value={vibratoDetect} onChange={(e)=>setVibratoDetect(parseInt(e.target.value))} className="w-full"/>
                        <div className="text-[10px] text-zinc-500 mt-1">
                          {vibratoDetect === 0 
                            ? 'Off - uses instantaneous pitch' 
                            : 'Detects symmetric vibrato and uses center pitch for accuracy'}
                        </div>
                      </div>
                      <div>
                        <div className="flex items-center justify-between text-xs text-zinc-400 mb-2">
                          <span>Show pitch grades</span>
                          <label className="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" checked={showGrades} onChange={(e)=>setShowGrades(e.target.checked)} className="sr-only peer"/>
                            <div className="w-9 h-5 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                          </label>
                        </div>
                        <div className="text-[10px] text-zinc-500">
                          Display average accuracy percentage above completed pitch sections
                        </div>
                      </div>
                      <div className="border-t border-zinc-700 pt-3 mt-3">
                        <div className="text-xs text-zinc-400 mb-2">Audio Source (Testing)</div>
                        <button 
                          className="w-full px-3 py-2 rounded-xl border border-zinc-600 text-zinc-300 hover:bg-zinc-800 text-xs"
                          onClick={async()=>{
                            try{
                              const stream = await navigator.mediaDevices.getDisplayMedia({ 
                                audio: { 
                                  echoCancellation: false, 
                                  noiseSuppression: false, 
                                  autoGainControl: false 
                                }, 
                                video: true // Required but we'll ignore the video track
                              });
                              // Remove video track - we only want audio
                              stream.getVideoTracks().forEach(track => track.stop());
                              if(stream.getAudioTracks().length === 0) {
                                alert('No audio track found. Make sure to select "Share audio" when sharing.');
                                return;
                              }
                              await initNodes(stream);
                              alert('System audio capture active. Close the screen share to return to microphone.');
                            }catch(err){ 
                              console.error('System audio capture failed', err); 
                              alert('Could not capture system audio. Try using microphone instead.');
                            }
                          }}
                        >
                          Capture System Audio (for testing)
                        </button>
                        <div className="text-[10px] text-zinc-500 mt-1">
                          Shares screen to capture internal audio. Use for testing with headphones.
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center justify-end gap-2 mt-4">
                      <button className="px-3 py-1.5 rounded-xl border border-white/10 text-zinc-300 hover:bg-white/5" onClick={()=>{ setTauMs(0); setLinePx(2); setGlowResp(0); setGlowInt(1.0); setLockTol(10); setLockWin(0.17); setVibratoDetect(0); }}>Reset</button>
                      <button className="px-3 py-1.5 rounded-xl bg-zinc-800 border border-white/10 text-zinc-100 hover:bg-zinc-700" onClick={()=>setSettingsOpen(false)}>Close</button>
                    </div>
                    </div>
                  </>
                )}
              </div>
            </div>

            {/* Workspace */}
            <div ref={containerRef} className="relative flex-1 grid grid-cols-[80px,1fr]" style={{overscrollBehavior:'contain', touchAction:'none', WebkitTouchCallout:'none', WebkitUserSelect:'none', userSelect:'none'}}>
              <canvas ref={railRef} className="h-full w-[80px]" style={{touchAction:'none'}}></canvas>
              <div className="relative h-full" style={{touchAction:'none'}}>
                <canvas ref={gridRef} className="absolute inset-0" style={{touchAction:'none'}}></canvas>
                <canvas ref={traceRef} className="absolute inset-0" style={{touchAction:'none'}}></canvas>
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
    </script>
  </body>
</html>
